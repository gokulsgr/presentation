<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Frontend Development: Basic Concepts</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/league.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		.reveal section {
			font-size: 30px;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>Frontend Development: Basic Concepts</h2>
			</section>
			<section>
				<h3>HTML & CSS</h3>
				<ul>
					<li>Semantic HTML</li>
					<li>Accessibility</li>
					<li>CSS Box Model (border-box)</li>
					<li>Flex and Grid concepts</li>
					<li>CSS Specificity and Selectors (Inline > ID > Class > Element)</li>
					<li>CSS Positioning (static, relative, absolute, fixed, sticky)</li>
					<li>CSS Responsive Design (Media Queries & Viewport)</li>
					<li>CSS Animations & Transition</li>
					<li>CSS-in-JS (styled-components, emotion, stitches)</li>
				</ul>
				<aside class="notes">
					<ul>
						As far as HTML is concerned, it's pretty straightforward.
						we need to learn about semantic tags they help with accessibility and SEO
						also we can use accessibility attributes like aria-label, aria-hidden, etc.(Accessible Rich Internet Applications)
						For CSS, we need to have a good understanding of Box Model, border-box,and then flex and grid concepts.
						And another important topic is CSS specificity - algorithm to determine which style rule applies to an element.
						if we have multiple styles applied to an element, the one with the highest specificity will be applied.
						The order goes like this: inline styles first, then ID selectors, then classes, and finally element selectors.  
						And then we have CSS positioning, responsive design, animations, and transitions as fundamental concepts.
						Earlier we used to write CSS in separate files, and scss was introduced to make it more maintainable.
						but problem with scss is if we have a large project, if we change a variable in one file, it will affect the whole project.
						so CSS-in-JS was introduced to solve this problem.it will create a unique class name for each component.
						so it will not affect the whole project.
					</ul>
				</aside>
			</section>
			<section>
				<section>
					<h3>Javascript Concepts</h3>
					<ul>
						<li>Hoisting in JavaScript</li>
						<li>Prototypal Inheritance</li>
						<li>Garbage Collection & Memory Management</li>
						<li>Closures & Lexical Scope</li>
						<li>Event Bubbling & Capturing</li>
						<li>Debouncing & Throttling</li>
						<li>Event Loop</li>
					</ul>
				</section>
				<section>
					<h3>Avoiding Stale Closures in React</h3>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						function Counter() {
							const [count, setCount] = useState(0);
						
							const handleClick = () => {
								setTimeout(() => {
									// Wrong way
									// setCount(count + 1);
									// Using functional update to avoid stale state
									setCount(prevCount =&gt; prevCount + 1);
								}, 1000);
							};
						
							return (
								&lt;div&gt;
									&lt;p&gt;Count: {count}&lt;/p&gt;
									&lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;
								&lt;/div&gt;
							);
						}
					</code></pre>
				</section>
				<section>
					<h3>Event Bubbling & Capturing</h3>
					<img src="dist/eventPropagation.webp" alt="Event Bubbling">
				</section>
				<section>
					<h3>Debouncing & Throttling</h3>
					<ul>
						<li>
							Debouncing: Delays execution until after a pause in input, optimizing performance by
							reducing unnecessary calls. Useful for search bars, auto-complete, etc.
						</li>
						<li class="fragment fade-up">Throttling: Limits function execution to a fixed time interval,
							ensuring consistent and controlled responsiveness. Useful for scroll events, resize events,
							etc.</li>
					</ul>
				</section>
				<section>
					<h3>Event Loop</h3>
					<ul>
						<li>Javascript is single-threaded, but it can run asynchronous code using the event loop.</li>
						<li>It is by which the js language behaves like a multi-threaded language, being
							single-threaded.</li>
						<li><a href="https://www.jsv9000.app/" target="_blank">Event Loop Visualizer</a></li>
					</ul>
				</section>
				<section>
					<a href="https://www.lydiahallie.com/blog/event-loop/"
						target="_blank">https://www.lydiahallie.com/blog/event-loop</a>
					<img src="dist/eventloop.gif" alt="Event Loop">
				</section>
				<section>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						console.log("Start");

						setTimeout(() => {
							console.log("Timeout Callback");
						}, 0);

						Promise.resolve().then(() => console.log("Promise Resolved"));

						console.log("End");
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h3>React</h3>
					<ul>
						<li>Virtual DOM</li>
						<li>Reconciliation (Diffing Algorithm)</li>
						<li>React Fiber</li>
						<li>
							<a href="https://react.dev/learn/thinking-in-react" target="_blank">Thinking in React</a>
						</li>
					</ul>
				</section>
				<section>
					<h3>React Optimization Techniques</h3>
					<ul>
						<li>Use React.memo() for Component Memoization</li>
						<li class="fragment fade-up">Optimize Expensive Computations/Functions using useMemo/useCallback
						</li>
						<li class="fragment fade-up">Use Lazy Loading and Code Splitting</li>
						<li class="fragment fade-up">Optimize List Rendering with key Prop</li>
						<li class="fragment fade-up">Don't use index as key</li>
					</ul>
				</section>
				<section>
					<h3>React Optimization Techniques</h3>
					<ul>
						<li class="fragment fade-up">Avoid Unnecessary State Updates</li>
						<li class="fragment fade-up">Use Context API Efficiently</li>
						<li class="fragment fade-up">Debounce and Throttle Expensive Functions</li>
						<li class="fragment fade-up">Optimize Image Loading with Lazy Loading</li>
					</ul>
				</section>
				<section>
					<h3>Downsides of useMemo and useCallback in React</h3>
					<ul>
						<li>If used excessively, it increases memory usage unnecessarily, especially for simple
							calculations.</li>
						<li>If dependencies change often, memoization becomes more expensive than recalculating the
							value.</li>
						<li>Use useMemo for expensive calculations that rarely change.</li>
						<li>Use useCallback if you pass functions as props to memoized child components (with
							React.memo)</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h3>General Performance Optimization</h3>
					<ul>
						<li>Critical Rendering Path</li>
						<li>Critical CSS</li>
						<li>Render-Blocking Resources</li>
						<li>Defer non-essential JavaScript (<code>defer</code> or <code>async</code>).</li>
						<li>Optimize Images</li>
					</ul>
				</section>
				<section>
					<h3>Core Web Vitals</h3>
					<ul>
						<li>FCP - First Contentful Paint (< 1.8 secs)</li>
						<li>LCP - Largest Contentful Paint (< 2.5 secs)</li>
						<li>INP - Interaction to Next Paint (< 2.5 secs)</li>
						<li>CLS - Cumulative Layout Shift (< 0.1)</li>
						<li>TBT - Total Blocking Time (< 300 ms)</li>
						<li>SI - Speed Index (< 4.3 secs)</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Module Bundlers</h3>
				<ul>
					<li>A module bundler takes multiple JavaScript files and dependencies, processes them, and outputs a
						single or multiple optimized files for the browser.</li>
					<li>Webpack</li>
					<li>Vite (Uses ES Module (ESM) and Rollup for bundling.)</li>
					<li>Hot module replacement</li>
					<li>Code Splitting</li>
					<li>Sourcemap</li>
				</ul>
			</section>
			<section>
				<section>
					<h3>Coding Principles</h3>
					<blockquote>DRY: Don't Repeat Yourself</blockquote>
					<ul>
						<li>Reusable Components</li>
						<li>Reusable Hooks</li>
						<li>Higher-Order Components</li>
						<li>Utility functions for common operations</li>
					</ul>
				</section>

				<section>
					<blockquote>KISS: Keep It Simple, Silly</blockquote>
					<p>
						This principle emphasizes simplicity in code, making it easier to read, maintain, and debug.
					</p>

					<blockquote>YAGNI: You Aren't Gonna Need It</blockquote>
					<p>
						This principle advises against adding functionality until it’s absolutely necessary. This helps
						keep code
						clean, maintainable, and avoids wasted effort on features that might never be used.
					</p>
				</section>

				<section>
					<h3>SOLID Principles</h3>
					<ul>
						<li><strong>S</strong> - Single Responsibility Principle (SRP)</li>
						<li><strong>O</strong> - Open/Closed Principle (OCP)</li>
						<li><strong>L</strong> - Liskov Substitution Principle (LSP)</li>
						<li><strong>I</strong> - Interface Segregation Principle (ISP)</li>
						<li><strong>D</strong> - Dependency Inversion Principle (DIP)</li>
					</ul>
				</section>

				<section>
					<h3>Single Responsibility Principle</h3>
					<p>
						A class should have only one reason to change, meaning that a class should have only one job.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							// Bad Example
							const BadButton = () => {
								const handleClick = () => {
									// some business logic
								};
			
								return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
							};
						</code>
					</pre>
				</section>

				<section>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							// Good Example
							const Button = ({ onClick, children }) =&gt; {
								return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;
							};
			
							const GoodButton = () =&gt; {
								const handleClick = () =&gt; {
									// some business logic
								};
			
								return &lt;Button onClick={handleClick}&gt;Click Me&lt;/Button&gt;;
							};
						</code>
					</pre>
				</section>
				<section>
					<h3>Open/Closed Principle</h3>
					<p>
						Software entities should be open for extension but closed for modification.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							const Button = ({ onClick, children, style }) => {
								const defaultStyle = {
									padding: "10px 20px",
									borderRadius: "5px",
									border: "none",
									cursor: "pointer",
									...style, // Allow custom styles to be passed
								};
			
								return (
									&lt;button onClick={onClick} style={defaultStyle}&gt;
										{children}
									&lt;/button&gt;
								);
							};
			
							const PrimaryButton = ({ onClick, children }) => {
								const primaryStyle = {
									backgroundColor: "blue",
									color: "white",
								};
			
								return (
									&lt;Button onClick={onClick} style={primaryStyle}&gt;
										{children}
									&lt;/Button&gt;
								);
							};
						</code>
					</pre>
				</section>
				<section>
					<h3>Liskov Substitution Principle</h3>
					<p>
						Objects of a superclass should be replaceable with objects of its subclasses without affecting
						the
						behavior of the program.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							const Button = ({ onClick, children }) =&gt; (
								&lt;button onClick={onClick}&gt;{children}&lt;/button&gt;
							);
							
							const PrimaryButton = (props) =&gt; &lt;Button {...props} className="primary" /&gt;;
							
							const IconButton = ({ icon, ...props }) =&gt; (
								&lt;Button {...props}&gt;
									&lt;span className="icon"&gt;{icon}&lt;/span&gt; {props.children}
								&lt;/Button&gt;
							);
							
							// Usage: Both can replace Button without breaking behavior
							&lt;Button onClick={() =&gt; alert("Clicked")}&gt;Click Me&lt;/Button&gt;
							&lt;PrimaryButton onClick={() =&gt; alert("Primary Clicked")}&gt;Primary&lt;/PrimaryButton&gt;
							&lt;IconButton onClick={() =&gt; alert("Icon Clicked")} icon="🔍"&gt;Search&lt;/IconButton&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>Interface Segregation Principle</h3>
					<p>
						It states that a component should not be forced to depend on interfaces it does not use.
						In React, this means that components should only receive the props they actually need.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							const Button = ({ onClick, text, borderColor, isOutlined }) =&gt; (
								&lt;button 
								  onClick={onClick} 
								  style={isOutlined ? { border: `2px solid ${borderColor}` } : {}}
								&gt;
								  {text}
								&lt;/button&gt;
							);
							  
							  // Usage
							  &lt;Button onClick={() =&gt; alert("Clicked")} text="Text Button" /&gt;
							  &lt;Button onClick={() =&gt; alert("Clicked")} text="Outlined Button" isOutlined borderColor="blue" /&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>Dependency Inversion Principle</h3>
					<p>
						High-level modules should not depend on low-level modules. Both should depend on abstractions.
					</p>
					<p>
						For example, in React, components should not depend on each other directly. Instead, they should
						depend on abstractions like props, context, or custom hooks.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h3>VS Code Extensions</h3>
					<ul>
						<li>DotENV</li>
						<li>ESLint</li>
						<li>GitLens</li>
						<li>Prettier</li>
						<li>ES7 React/Redux/GraphQL/React-Native snippets</li>
						<li>Path Intellisense</li>
						<li>Sort lines</li>
						<li>Continue in combination with ollama</li>
						<li>Gist</li>
						<li>Git History</li>
					</ul>
				</section>
				<section>
					<h3>Terminal commands and plugins</h3>
					<ul>
						<li>oh my zsh</li>
						<li>zsh-autosuggestions</li>
						<li>zsh-syntax-highlighting</li>
						<li><code>code .</code> : Open VS code in the current directory</li>
						<li>create alias in ~/.bash_profile for most used commands</li>
						<li><code>source ~/.bash_profile</code> : To apply changes in bash_profile</li>
						<li>use pm2 for running apps in background</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Emerging Trends in frontend</h3>
				<ul>
					<li>WASM with Assembly script</li>
					<li>Micro Frontends</li>
				</ul>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			navigationMode: 'linear',
			hash: true,
			controls: true,
			progress: true,
			center: true,
			transition: 'slide',
			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>