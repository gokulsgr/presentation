<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Frontend Development: Basic Concepts</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/league.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
	<style>
		.reveal section {
			font-size: 30px;
		}
	</style>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>Frontend Development: Basic Concepts</h2>
			</section>
			<section>
				<section>
					<h3>Javascript Concepts</h3>
					<ul>
						<li>Hoisting</li>
						<li>Garbage Collection & Memory Management</li>
						<li>Prototypal Inheritance</li>
						<li>Closures & Lexical Scope</li>
						<li>Event Bubbling & Capturing</li>
						<li>Event delegation</li>
						<li>Debouncing & Throttling</li>
						<li>Event Loop</li>
						<li>Shallow vs Deep Copy</li>
					</ul>
				</section>
				<section>
					<h3>Hoisting</h3>
					<ul>
						<li>
							Hoisting is a JavaScript mechanism where variables and function declarations are moved to
							the top
							of their scope before code execution.
						</li>
					</ul>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							for (var i = 0; i < 3; i++) {
								setTimeout(function() {
									console.log(i); // 3, 3, 3
								}, 100);
							}
						</code>
					</pre>
					<aside class="notes">
						<ul>
							Hoisting is a JavaScript mechanism where variables and function declarations are moved to
							the top of their scope before code execution.
							Function declarations are hoisted,
							React Hooks are not affected by hoisting because they rely on the order of the calls.but
							must always be called at the top level.
							Arrow functions (event handlers, callbacks) are not hoisted, so declare them before using.
						</ul>
					</aside>
				</section>
				<section>
					<h3>Garbage Collection & Memory Management</h3>
					<ul>
						<li>JavaScript has automatic garbage collection, meaning it manages memory allocation and
							deallocation for you.</li>
						<li>Memory leaks can occur if you forget to remove global variables or event listeners.</li>
					</ul>
					<aside class="notes">
						<ul>
							JavaScript has automatic garbage collection, meaning it manages memory allocation and
							deallocation for you.
							we don't have to worry about memory management in javascript. but we need to be careful with
							memory leaks.
							For example, if we have a global variable and we forget to remove it, it will cause a memory
							leak.
						</ul>
					</aside>
				</section>
				<section>
					<h3>Prototypal Inheritance</h3>
					<ul>
						<li>JavaScript uses prototypal inheritance, where objects inherit properties and methods from
							other objects.</li>
						<li>Every object has a "__proto__" property, which allows objects to inherit properties and
							methods from other objects.</li>
					</ul>
					<aside class="notes">
						<ul>
							Prototypal Inheritance is a way to share methods and properties between objects in
							JavaScript.
							Because everything in JavaScript is an object, when it comes to inheritance, objects inherit
							from other objects.
						</ul>
					</aside>
				</section>
				<section>
					<h3>Closures & Lexical Scope</h3>
					<ul>
						<li>A closure in JavaScript is a function that remembers the variables from its outer scope even after the outer function has finished executing.</li>
						<li>Lexical scope means that a function can access variables from its parent function, even if
							it's called outside the parent function.</li>
					</ul>
					<aside class="notes">
						<ul>
							if we use outer variables inside a function, it will create a closure.
							But the downside is that they can cause memory leaks if not handled properly.
						</ul>
					</aside>
				</section>
				<section>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						function outer() {
							let count = 0;
							
							return function inner() {
							  count++;
							  console.log(count);
							};
						  }
						  
						  const counter = outer(); // outer() runs and returns inner()
						  counter(); // 1
						  counter(); // 2
						  counter(); // 3
						</code></pre>
				</section>
				<section>
					<h3>Avoiding Stale Closures in React</h3>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						function Counter() {
							const [count, setCount] = useState(0);
						
							const handleClick = () => {
								setTimeout(() => {
									// Wrong way
									// setCount(count + 1);
									// Using functional update to avoid stale state
									setCount(prevCount =&gt; prevCount + 1);
								}, 1000);
							};
						
							return (
								&lt;div&gt;
									&lt;p&gt;Count: {count}&lt;/p&gt;
									&lt;button onClick={handleClick}&gt;Increment&lt;/button&gt;
								&lt;/div&gt;
							);
						}
					</code></pre>
				</section>

				<section>
					<h3>Event Bubbling & Capturing</h3>
					<img src="dist/eventPropagation.webp" alt="Event Bubbling">
					<aside class="notes">
						<ul>
						</ul>
					</aside>
				</section>
				<section>
					<h3>Debouncing & Throttling</h3>
					<ul>
						<li>
							Debouncing: Delays execution until after a pause in input, optimizing performance by
							reducing unnecessary calls. Useful for search bars, auto-complete, etc.
						</li>
						<li class="fragment fade-up">
							Throttling: Limits function execution to a fixed time interval,
							ensuring consistent and controlled responsiveness. Useful for scroll events, resize events,
							etc.
						</li>
					</ul>
					<aside class="notes">
						<ul>
							Debouncing is mainly used to reduce the number of API calls. so if we have a search bar and
							we want to
							make an API call after the user stops typing, we can use debouncing.
							Throttling is used to limit the number of times a function is called. for example, if we
							have a scroll event
							and we want to call a function after every 100ms, we can use throttling.
						</ul>
				</section>
				<section>
					<h3>Event Loop</h3>
					<ul>
						<li>Javascript is single-threaded, but it can run asynchronous code using the event loop.</li>
						<li>It is by which the js language behaves like a multi-threaded language, being
							single-threaded.</li>
						<li><a href="https://www.jsv9000.app/" target="_blank">Event Loop Visualizer</a></li>
					</ul>
				</section>
				<section>
					<a href="https://www.lydiahallie.com/blog/event-loop/"
						target="_blank">https://www.lydiahallie.com/blog/event-loop</a>
					<img src="dist/eventloop.gif" alt="Event Loop">
				</section>
				<section>
					<pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers>
						console.log("Start");

						setTimeout(() => {
							console.log("Timeout Callback");
						}, 0);

						Promise.resolve().then(() => console.log("Promise Resolved"));

						console.log("End");
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h3>React</h3>
					<ul>
						<li>Virtual DOM</li>
						<li>Reconciliation (Diffing Algorithm)</li>
						<li>React Fiber</li>
						<li>
							<a href="https://react.dev/learn/thinking-in-react" target="_blank">Thinking in React</a>
						</li>
					</ul>
				</section>
				<section>
					<h3>Rules of Hooks</h3>
					<ul>
						<li>Only Call Hooks at the Top Level</li>
						<li>Only Call Hooks from React Functions or Custom Hooks</li>
						<li>Don't call Hooks inside loops, conditions, or nested functions</li>
					</ul>
					<aside class="notes">
						React Hooks are functions that enable functional components to use React state and lifecycle
						features. They eliminate the need for class components, making code cleaner and easier to
						maintain.
						Custom Hooks are user-defined functions that encapsulate reusable logic
					</aside>
				</section>
				<section>
					<h3>React Optimization Techniques</h3>
					<ul>
						<li>Use React.memo() for Component Memoization</li>
						<li class="fragment fade-up">Optimize Expensive Computations/Functions using useMemo/useCallback
						</li>
						<li class="fragment fade-up">Use Lazy Loading and Code Splitting</li>
						<li class="fragment fade-up">Optimize List Rendering with key Prop</li>
						<li class="fragment fade-up">Don't use index as key</li>
					</ul>
				</section>
				<section>
					<h3>React(Continued)</h3>
					<ul>
						<li class="fragment fade-up">Avoid Unnecessary State Updates</li>
						<li class="fragment fade-up">Use Context API Efficiently</li>
						<li class="fragment fade-up">Debounce and Throttle Expensive Functions</li>
						<li class="fragment fade-up">Optimize Image Loading with Lazy Loading</li>
						<li class="fragment fade-up">Use TypeScript for Type Safety</li>
					</ul>
				</section>
				<section>
					<h3>Downsides of useMemo and useCallback in React</h3>
					<ul>
						<li>If used excessively, it increases memory usage unnecessarily, especially for simple
							calculations.</li>
						<li>If dependencies change often, memoization becomes more expensive than recalculating the
							value.</li>
						<li>Use useMemo for expensive calculations that rarely change.</li>
						<li>Use useCallback if you pass functions as props to memoized child components (with
							React.memo)</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>HTML & CSS</h3>
				<ul>
					<li>Semantic HTML</li>
					<li>Accessibility</li>
					<li>CSS Box Model (border-box)</li>
					<li>Flex and Grid concepts</li>
					<li>CSS Specificity and Selectors (Inline > ID > Class > Element)</li>
					<li>CSS Positioning (static, relative, absolute, fixed, sticky)</li>
					<li>CSS Responsive Design (Media Queries & Viewport)</li>
					<li>CSS Animations & Transition</li>
					<li>CSS-in-JS (styled-components, emotion, stitches)</li>
				</ul>
				<aside class="notes">
					<ul>
						As far as HTML is concerned, it's pretty straightforward.
						we need to learn about semantic tags they help with accessibility and SEO
						also we can use accessibility attributes like aria-label, aria-hidden, etc.(Accessible Rich
						Internet Applications)
						For CSS, we need to have a good understanding of Box Model, border-box,and then flex and grid
						concepts.
						And another important topic is CSS specificity - algorithm to determine which style rule applies
						to an element.
						if we have multiple styles applied to an element, the one with the highest specificity will be
						applied.
						The order goes like this: inline styles first, then ID selectors, then classes, and finally
						element selectors.
						And then we have CSS positioning, responsive design, animations, and transitions as fundamental
						concepts.
						Earlier we used to write CSS in separate files, and scss was introduced to make it more
						maintainable.
						but problem with scss is if we have a large project, if we change a variable in one file, it
						will affect the whole project.
						so CSS-in-JS was introduced to solve this problem.it will create a unique class name for each
						component.
						so it will not affect the whole project.
					</ul>
				</aside>
			</section>
			<section>
				<section>
					<h3>General Performance Optimization</h3>
					<ul>
						<li>Critical Rendering Path</li>
						<li>Critical CSS</li>
						<li>Render-Blocking Resources</li>
						<li>Defer non-essential JavaScript (<code>defer</code> or <code>async</code>).</li>
						<li>Optimize Images</li>
					</ul>
				</section>
				<section>
					<h3>Core Web Vitals</h3>
					<ul>
						<li>FCP - First Contentful Paint (< 1.8 secs)</li>
						<li>LCP - Largest Contentful Paint (< 2.5 secs)</li>
						<li>INP - Interaction to Next Paint (< 2.5 secs)</li>
						<li>CLS - Cumulative Layout Shift (< 0.1)</li>
						<li>TBT - Total Blocking Time (< 300 ms)</li>
						<li>SI - Speed Index (< 4.3 secs)</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Module Bundlers</h3>
				<ul>
					<li>A module bundler takes multiple JavaScript files and dependencies, processes them, and outputs a
						single or multiple optimized files for the browser.</li>
					<li>Webpack</li>
					<li>Vite (Uses ES Module (ESM) and Rollup for bundling.)</li>
					<li>Hot module replacement</li>
					<li>Code Splitting</li>
					<li>Sourcemap</li>
				</ul>
			</section>
			<section>
				<section>
					<h3>Coding Principles</h3>
					<blockquote>DRY: Don't Repeat Yourself</blockquote>
					<ul>
						<li>Reusable Components</li>
						<li>Reusable Hooks</li>
						<li>Higher-Order Components</li>
						<li>Utility functions for common operations</li>
					</ul>
				</section>

				<section>
					<blockquote>KISS: Keep It Simple, Silly</blockquote>
					<p>
						This principle emphasizes simplicity in code, making it easier to read, maintain, and debug.
					</p>

					<blockquote>YAGNI: You Aren't Gonna Need It</blockquote>
					<p>
						This principle advises against adding functionality until it‚Äôs absolutely necessary. This helps
						keep code
						clean, maintainable, and avoids wasted effort on features that might never be used.
					</p>
				</section>

				<section>
					<h3>SOLID Principles</h3>
					<ul>
						<li><strong>S</strong> - Single Responsibility Principle (SRP)</li>
						<li><strong>O</strong> - Open/Closed Principle (OCP)</li>
						<li><strong>L</strong> - Liskov Substitution Principle (LSP)</li>
						<li><strong>I</strong> - Interface Segregation Principle (ISP)</li>
						<li><strong>D</strong> - Dependency Inversion Principle (DIP)</li>
					</ul>
				</section>

				<section>
					<h3>Single Responsibility Principle</h3>
					<p>
						A class should have only one reason to change, meaning that a class should have only one job.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							// Bad Example
							const BadButton = () => {
								const handleClick = () => {
									// some business logic
								};
			
								return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
							};

							// Good Example
							const Button = ({ onClick, children }) =&gt; {
								return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;
							};
			
							const GoodButton = () =&gt; {
								const handleClick = () =&gt; {
									// some business logic
								};
			
								return &lt;Button onClick={handleClick}&gt;Click Me&lt;/Button&gt;;
							};
						</code>
					</pre>
				</section>
				<section>
					<h3>Open/Closed Principle</h3>
					<p>
						Software entities should be open for extension but closed for modification.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							const Button = ({ onClick, children, style, ...rest }) => {
								const defaultStyle = {
									cursor: "pointer",
									...style, // Allow custom styles to be passed
								};
			
								return (
									&lt;button onClick={onClick} style={defaultStyle} {...rest} &gt;
										{children}
									&lt;/button&gt;
								);
							};
			
							const PrimaryButton = ({ onClick, children }) => {
								const primaryStyle = {
									backgroundColor: "blue",
									color: "white",
								};
			
								return (
									&lt;Button onClick={onClick} style={primaryStyle}&gt;
										{children}
									&lt;/Button&gt;
								);
							};
						</code>
					</pre>
				</section>
				<section>
					<h3>Liskov Substitution Principle</h3>
					<p>
						Objects of a superclass should be replaceable with objects of its subclasses without affecting
						the
						behavior of the program.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							const Button = ({ onClick, children }) =&gt; (
								&lt;button onClick={onClick}&gt;{children}&lt;/button&gt;
							);
							
							const PrimaryButton = (props) =&gt; &lt;Button {...props} className="primary" /&gt;;
							
							const IconButton = ({ icon, ...props }) =&gt; (
								&lt;Button {...props}&gt;
									&lt;span className="icon"&gt;{icon}&lt;/span&gt; {props.children}
								&lt;/Button&gt;
							);
							
							// Usage: Both can replace Button without breaking behavior
							&lt;Button onClick={() =&gt; alert("Clicked")}&gt;Click Me&lt;/Button&gt;
							&lt;PrimaryButton onClick={() =&gt; alert("Primary Clicked")}&gt;Primary&lt;/PrimaryButton&gt;
							&lt;IconButton onClick={() =&gt; alert("Icon Clicked")} icon="üîç"&gt;Search&lt;/IconButton&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>Interface Segregation Principle</h3>
					<p>
						It states that a component should not be forced to depend on interfaces it does not use.
						In React, this means that components should only receive the props they actually need.
					</p>
					<pre data-id="code-animation">
						<code class="hljs javascript" data-trim data-line-numbers>
							// wrong way
							const Button = ({ onClick, text, borderColor, isOutlined }) =&gt; (
								&lt;button 
								  onClick={onClick} 
								  style={isOutlined ? { border: `2px solid ${borderColor}` } : {}}
								&gt;
								  {text}
								&lt;/button&gt;
							);
							  
							  // Usage
							  &lt;Button onClick={() =&gt; alert("Clicked")} text="Text Button" /&gt;
							  &lt;Button onClick={() =&gt; alert("Clicked")} text="Outlined Button" isOutlined borderColor="blue" /&gt;

							  // correct way
							  const Button = ({ onClick, children }) =&gt; (
								&lt;button onClick={onClick}&gt;{children}&lt;/button&gt;
							  );

							  const TextButton = ({ onClick, children }) =&gt; (
								&lt;Button onClick={onClick}&gt;{children}&lt;/Button&gt;
							  );

							  const OutlinedButton = ({ onClick, children, borderColor }) =&gt; (
								&lt;Button onClick={onClick} style={{ border: `2px solid ${borderColor}` }}&gt;
								  {children}
								&lt;/Button&gt;
							  );
							  
							  // Usage
							  &lt;TextButton onClick={() =&gt; alert("Clicked")}&gt;Text Button&lt;/TextButton&gt;
							  &lt;OutlinedButton onClick={() =&gt; alert("Clicked")} borderColor="blue"&gt;Outlined Button&lt;/OutlinedButton&gt;
						</code>
					</pre>
				</section>
				<section>
					<h3>Dependency Inversion Principle</h3>
					<p>
						High-level modules should not depend on low-level modules. Both should depend on abstractions.
					</p>
					<p>
						In React, components should not depend on each other directly. Instead, they should
						depend on abstractions like props, context, or custom hooks.
						Instead of directly using a specific authentication service (e.g., Firebase) inside a React component, depend on an abstraction like an AuthService interface. 
						This allows swapping implementations (e.g., Firebase, Auth0) without modifying components, adhering to the Dependency Inversion Principle.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h3>VS Code Extensions</h3>
					<ul>
						<li>DotENV</li>
						<li>ESLint</li>
						<li>GitLens</li>
						<li>Prettier</li>
						<li>ES7 React/Redux/GraphQL/React-Native snippets</li>
						<li>Path Intellisense</li>
						<li>Sort lines</li>
						<li>Continue in combination with ollama</li>
						<li>Gist</li>
						<li>Git History</li>
					</ul>
				</section>
				<section>
					<h3>Terminal</h3>
					<ul>
						<li><code>code .</code> : Open VS code in the current directory</li>
						<li>iterm, oh my zsh(zsh-autosuggestions, zsh-syntax-highlighting)</li>
						<li>create alias in ~/.bash_profile for most used commands and source it</li>
						<li>use WARP AI terminal</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Emerging Trends in frontend</h3>
				<ul>
					<li>WASM with Assembly script</li>
					<li>Micro Frontends</li>
				</ul>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			navigationMode: 'linear',
			hash: true,
			controls: true,
			progress: true,
			center: true,
			transition: 'slide',
			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>